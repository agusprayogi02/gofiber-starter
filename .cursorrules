# Go Fiber Starter Kit - AI Assistant Rules

This file guides AI assistants in generating code that follows the established patterns, architecture, and best practices of the Go Fiber Starter Kit project.

## Project Context & Architecture

### Architecture Overview

This project uses **Clean Architecture** with **Domain-Driven Design (DDD)** principles. The architecture is organized into distinct layers with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────┐
│                        HTTP Layer                            │
│                     (Fiber Framework)                        │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                    Handler Layer                             │
│              (Request/Response Handling)                     │
│         - Validate Input                                     │
│         - Call Service                                       │
│         - Return Response                                    │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                    Service Layer                             │
│                  (Business Logic)                            │
│         - Implement Use Cases                               │
│         - Coordinate Repositories                            │
│         - Handle Transactions                                │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                  Repository Layer                            │
│                 (Data Access Logic)                          │
│         - CRUD Operations                                    │
│         - Database Queries                                   │
│         - ORM Abstraction                                    │
└──────────────────────┬──────────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────────┐
│                    Database Layer                            │
│                   (PostgreSQL/MySQL)                         │
└─────────────────────────────────────────────────────────────┘
```

### Layer Responsibilities

1. **Domain Layer** (`internal/domain/`) - Pure business entities, DTOs, and interfaces
   - No dependencies on other layers
   - Contains: `entity.go`, `dto.go`, `repository.go`, `service.go`
   - Example: `internal/domain/user/`

2. **Repository Layer** (`internal/repository/postgres/`) - Data access implementations
   - Implements domain repository interfaces
   - Uses GORM for database operations
   - Example: `internal/repository/postgres/user.go`

3. **Service Layer** (`internal/service/`) - Business logic implementations
   - Implements domain service interfaces
   - Uses repositories for data access
   - Returns DTOs, not entities
   - Example: `internal/service/auth/service.go`

4. **Handler Layer** (`internal/handler/http/`) - HTTP request handlers
   - Parses and validates requests
   - Calls service methods
   - Returns formatted responses
   - Example: `internal/handler/http/auth.go`

5. **Router Layer** (`router/`) - Route definitions and registration
   - Defines API routes and endpoints
   - Applies middleware (auth, rate limit, etc.)
   - Registers handlers from `internal/handler/http/`
   - Example: `router/auth.go`, `router/post.go`

6. **Infrastructure Layer** (`internal/infrastructure/`) - External services
   - Email, Cache, Storage implementations
   - Example: `internal/infrastructure/storage/`

### Dependency Direction

**CRITICAL**: Dependencies must flow in ONE direction only:
- Router → Handler → Service → Repository → Database
- Domain layer has NO dependencies
- Never reverse dependencies (e.g., Service → Handler, Handler → Router)
- Router depends on Handler, but Handler does NOT depend on Router

## Code Style & Conventions

### Naming Conventions

**Variables & Functions:**
```go
// ✅ Good - camelCase for private
var userRepository user.Repository
func getUserByEmail(email string) (*user.User, error) {}

// ✅ Good - PascalCase for public/exported
var UserService *AuthService
func GetUserProfile(id uint) (*user.UserResponse, error) {}

// ❌ Bad - NEVER use snake_case in Go
var user_repository UserRepository
func get_user_by_email(email string) {}
```

**Structs & Interfaces:**
```go
// ✅ Good - singular, descriptive, PascalCase
type User struct {}
type UserRepository interface {}
type AuthService struct {}

// ❌ Bad - plural, abbreviated
type Users struct {}
type UsrRepo interface {}
type AuthSvc struct {}
```

**Constants:**
```go
// ✅ Good - PascalCase for exported
const (
    AdminR UserRole = "admin"
    UserR  UserRole = "user"
)

const DefaultPageSize = 10

// ✅ Good - camelCase for private
const maxRetries = 3
```

**Files:**
- Use lowercase with underscores: `user_repository.go`, `auth_handler.go`
- Match package name: `postgres/user.go` (package postgres)

### Import Organization

**ALWAYS** organize imports in this order:
```go
import (
    // 1. Standard library
    "fmt"
    "time"
    "strconv"
    
    // 2. External packages
    "github.com/gofiber/fiber/v2"
    "gorm.io/gorm"
    
    // 3. Internal packages (group by domain)
    "starter-gofiber/internal/domain/user"
    "starter-gofiber/internal/domain/post"
    "starter-gofiber/pkg/apierror"
    "starter-gofiber/pkg/crypto"
    "starter-gofiber/pkg/dto"
    "starter-gofiber/pkg/response"
)
```

### Error Handling

**ALWAYS** use custom error types from `pkg/apierror/`:

```go
// ✅ Good - Custom error with Order tracking
if err := s.userRepo.Create(user); err != nil {
    return &apierror.InternalServerError{
        Message: "Failed to create user",
        Order:   "S1", // Track error location: S=Service, H=Handler, R=Repository
    }
}

// ✅ Good - Check error immediately
user, err := s.userRepo.FindByEmail(email)
if err != nil {
    return nil, &apierror.NotFoundError{
        Message: "User not found",
        Order:   "S1",
    }
}

// ❌ Bad - NEVER ignore errors
user, _ := s.userRepo.FindByEmail(email)

// ❌ Bad - NEVER return raw errors without context
if err != nil {
    return nil, err
}
```

**Available Error Types:**
- `apierror.BadRequestError` - 400
- `apierror.UnauthorizedError` - 401
- `apierror.ForbiddenError` - 403
- `apierror.NotFoundError` - 404
- `apierror.UnprocessableEntityError` - 422
- `apierror.InternalServerError` - 500
- `apierror.TooManyRequestsError` - 429

**Order Field Convention:**
- `H1`, `H2` - Handler layer errors
- `S1`, `S2` - Service layer errors
- `R1`, `R2` - Repository layer errors
- `S-Register-3` - Specific operation tracking

## Architecture Patterns

### Domain Layer Structure

When creating a new domain (e.g., `product`, `order`), create this structure:

```
internal/domain/{domain_name}/
├── entity.go      # GORM models (database entities)
├── dto.go         # Request/Response DTOs
├── repository.go  # Repository interface
└── service.go     # Service interface
```

**Example: `internal/domain/user/entity.go`**
```go
package user

import "gorm.io/gorm"

type User struct {
    ID            uint   `gorm:"primaryKey;autoIncrement"`
    Name          string `gorm:"type:varchar(200);not null"`
    Email         string `gorm:"type:varchar(200);uniqueIndex;not null"`
    Password      string `gorm:"type:varchar(150);not null"`
    EmailVerified bool   `gorm:"default:false"`
    gorm.Model
}
```

**Example: `internal/domain/user/dto.go`**
```go
package user

type RegisterRequest struct {
    Name     string `json:"name" binding:"required;min=3"`
    Email    string `json:"email" binding:"required;email"`
    Password string `json:"password" binding:"required;min=6"`
}

type UserResponse struct {
    ID        uint   `json:"id"`
    Name      string `json:"name"`
    Email     string `json:"email"`
    CreatedAt string `json:"created_at"`
    UpdatedAt string `json:"updated_at"`
}

// Conversion methods
func (r UserResponse) FromEntity(u User) UserResponse {
    return UserResponse{
        ID:        u.ID,
        Name:      u.Name,
        Email:     u.Email,
        CreatedAt: u.CreatedAt.Format(time.RFC3339),
        UpdatedAt: u.UpdatedAt.Format(time.RFC3339),
    }
}

func (r RegisterRequest) ToEntity() User {
    return User{
        Name:     r.Name,
        Email:    r.Email,
        Password: r.Password,
    }
}
```

**Example: `internal/domain/user/repository.go`**
```go
package user

type Repository interface {
    Create(user *User) error
    FindByEmail(email string) (*User, error)
    FindByID(id uint) (*User, error)
    Update(user *User) error
    Delete(id uint) error
}
```

**Example: `internal/domain/user/service.go`**
```go
package user

type Service interface {
    Register(req *RegisterRequest) error
    Login(req *LoginRequest) (*LoginResponse, error)
    GetProfile(userID uint) (*GetProfileResponse, error)
}
```

### Implementation Structure

**Repository Implementation: `internal/repository/postgres/user.go`**
```go
package postgres

import (
    "starter-gofiber/internal/domain/user"
    "gorm.io/gorm"
)

type UserRepository struct {
    db *gorm.DB
}

func NewUserRepository(d *gorm.DB) user.Repository {
    return &UserRepository{db: d}
}

func (r *UserRepository) Create(m *user.User) error {
    return r.db.Create(m).Error
}

func (r *UserRepository) FindByEmail(email string) (*user.User, error) {
    var usr user.User
    err := r.db.Where("email = ?", email).First(&usr).Error
    if err != nil {
        return nil, err
    }
    return &usr, nil
}
```

**Service Implementation: `internal/service/auth/service.go`**
```go
package auth

import (
    "starter-gofiber/internal/domain/user"
    "starter-gofiber/pkg/apierror"
    "starter-gofiber/pkg/crypto"
)

type AuthService struct {
    userRepo user.Repository
}

func NewAuthService(userRepo user.Repository) user.Service {
    return &AuthService{userRepo: userRepo}
}

func (s *AuthService) Register(req *user.RegisterRequest) error {
    // Business logic here
    if err := s.userRepo.ExistEmail(req.Email); err == nil {
        return &apierror.BadRequestError{
            Message: "Email already exists",
            Order:   "S1",
        }
    }
    
    password, err := crypto.HashPassword(req.Password)
    if err != nil {
        return &apierror.BadRequestError{
            Message: "Failed to hash password",
            Order:   "S2",
        }
    }
    
    userEntity := req.ToEntity()
    userEntity.Password = password
    
    return s.userRepo.Create(&userEntity)
}
```

**Handler Implementation: `internal/handler/http/auth.go`**
```go
package http

import (
    "starter-gofiber/internal/domain/user"
    "starter-gofiber/pkg/apierror"
    "starter-gofiber/pkg/dto"
    "starter-gofiber/pkg/response"
    "github.com/gofiber/fiber/v2"
)

type AuthHandler struct {
    userS user.Service
}

func NewAuthHandler(s user.Service) *AuthHandler {
    return &AuthHandler{userS: s}
}

func (h *AuthHandler) Register(c *fiber.Ctx) error {
    var req *user.RegisterRequest
    if err := c.BodyParser(&req); err != nil {
        return &apierror.UnprocessableEntityError{
            Message: err.Error(),
            Order:   "H1",
        }
    }
    
    if err := h.userS.Register(req); err != nil {
        return err
    }
    
    return response.Response(dto.ResponseResult{
        StatusCode: fiber.StatusCreated,
        Message:    "User registered successfully",
    }, c)
}
```

## API Design Guidelines

### Endpoint Conventions

**RESTful Routes:**
- Public endpoints: `/api/{resource}` (e.g., `/api/register`, `/api/login`)
- Protected endpoints: `/api/auth/{resource}` (e.g., `/api/auth/profile`)
- Resource endpoints: `/api/{resource}` or `/api/{resource}/:id`
- Use proper HTTP methods: GET, POST, PUT, DELETE

**Route Registration: `router/auth.go`**
```go
package router

import (
    "starter-gofiber/internal/config"
    "starter-gofiber/internal/handler/http"
    "starter-gofiber/internal/handler/middleware"
    "starter-gofiber/internal/repository/postgres"
    "starter-gofiber/internal/service/auth"
    
    "github.com/casbin/casbin/v2"
    "github.com/gofiber/fiber/v2"
)

func NewAuthentication(app fiber.Router, enforcer *casbin.Enforcer) {
    userRepo := postgres.NewUserRepository(config.DB)
    authService := auth.NewAuthService(userRepo)
    authHandler := http.NewAuthHandler(authService)
    
    // Public routes
    app.Post("/register", authHandler.Register(enforcer))
    app.Post("/login", authHandler.Login)
    
    // Protected routes
    authMiddleware := middleware.AuthMiddleware()
    app.Get("/profile", authMiddleware, authHandler.GetProfile)
    app.Put("/profile", authMiddleware, authHandler.UpdateProfile)
}
```

**Router Setup: `router/router.go`**
```go
func AppRouter(app *fiber.App) {
    // API routes
    api := app.Group("/api")
    auth := api.Group("/auth")
    NewAuthentication(auth, config.Enforcer)
    NewPostRouter(api)
}
```

### Request/Response Structure

**Request DTOs:**
```go
type CreateRequest struct {
    Name  string `json:"name" binding:"required,min=3"`
    Email string `json:"email" binding:"required,email"`
}
```

**Response Format:**
```go
// Success response
{
    "code": 200,
    "status": "success",
    "message": "Operation successful",
    "data": {...},
    "paginate": {...}  // Optional, for paginated responses
}

// Error response
{
    "code": 400,
    "status": "error",
    "message": "Error message",
    "order": "S1",
    "timestamp": "2026-01-01T00:00:00Z"
}
```

**Response Helper Usage:**
```go
// With data
return response.Response(dto.ResponseResult{
    StatusCode: fiber.StatusOK,
    Message:    "Success message",
    Data:       responseData,
}, c)

// Without data
return response.Response(dto.ResponseResult{
    StatusCode: fiber.StatusCreated,
    Message:    "Resource created",
}, c)

// With pagination
return response.Response(dto.ResponseResult{
    StatusCode: fiber.StatusOK,
    Message:    "List retrieved",
    Data:       items,
    Paginate:   &paginationMeta,
}, c)
```

## Database Patterns

### GORM Best Practices

**Entity Definition:**
```go
type User struct {
    ID            uint   `gorm:"primaryKey;autoIncrement"`
    Name          string `gorm:"type:varchar(200);not null"`
    Email         string `gorm:"type:varchar(200);uniqueIndex;not null"`
    Password      string `gorm:"type:varchar(150);not null"`
    EmailVerified bool   `gorm:"default:false"`
    gorm.Model  // Includes ID, CreatedAt, UpdatedAt, DeletedAt
}
```

**Key Practices:**
1. **Use Migrations**: Always create migration files in `migrations/` for schema changes
2. **Define Indexes**: Use `uniqueIndex` or `index` tags in entity structs
3. **Eager Loading**: Use `Preload()` to avoid N+1 queries
4. **Soft Deletes**: Use `gorm.DeletedAt` for soft delete functionality
5. **Transactions**: Use transactions for multi-step operations

**Repository Pattern:**
```go
type Repository interface {
    Create(entity *Entity) error
    FindByID(id uint) (*Entity, error)
    FindByEmail(email string) (*Entity, error)
    Update(entity *Entity) error
    Delete(id uint) error
}
```

**Query Examples:**
```go
// Find with conditions
func (r *UserRepository) FindByEmail(email string) (*user.User, error) {
    var usr user.User
    err := r.db.Where("email = ?", email).First(&usr).Error
    if err != nil {
        return nil, err
    }
    return &usr, nil
}

// Eager loading (avoid N+1)
func (r *PostRepository) FindWithUser(id uint) (*post.Post, error) {
    var p post.Post
    err := r.db.Preload("User").Where("id = ?", id).First(&p).Error
    return &p, err
}

// Pagination
func (r *PostRepository) FindAll(page, pageSize int) ([]post.Post, int64, error) {
    var posts []post.Post
    var total int64
    
    offset := (page - 1) * pageSize
    r.db.Model(&post.Post{}).Count(&total)
    err := r.db.Offset(offset).Limit(pageSize).Find(&posts).Error
    
    return posts, total, err
}
```

## Security Requirements

### Authentication

**JWT Token Handling:**
```go
// Extract user from token in handler
userClaims, err := crypto.GetUserFromToken(c)
if err != nil {
    return err
}

// Use authenticated user ID (NEVER trust client-provided IDs)
req.UserID = userClaims.ID
```

**Middleware Usage:**
```go
// Apply auth middleware to protected routes
authMiddleware := middleware.AuthMiddleware()
app.Get("/auth/profile", authMiddleware, authHandler.GetProfile)
```

**Security Rules:**
- ✅ ALWAYS extract user from JWT token, never from request body
- ✅ ALWAYS overwrite user ID from request with authenticated user ID
- ✅ NEVER expose passwords in API responses
- ✅ ALWAYS hash passwords before storing (use `crypto.HashPassword`)
- ✅ Use HTTPS in production

### Authorization

**Casbin RBAC:**
- Define policies in `assets/rbac/policy.csv`
- Check permissions before sensitive operations
- Verify ownership before update/delete operations

**Ownership Check Example:**
```go
func (s *PostService) Update(postID uint, userID uint, req *post.PostUpdateRequest) error {
    // First, verify ownership
    existingPost, err := s.postRepo.FindByID(postID)
    if err != nil {
        return &apierror.NotFoundError{Message: "Post not found", Order: "S1"}
    }
    
    // Check ownership
    if existingPost.UserID != userID {
        return &apierror.ForbiddenError{
            Message: "You don't have permission to update this post",
            Order:   "S2",
        }
    }
    
    // Proceed with update
    // ...
}
```

### Input Validation

**Handler-Level Validation:**
```go
func (h *AuthHandler) Register(c *fiber.Ctx) error {
    var req *user.RegisterRequest
    if err := c.BodyParser(&req); err != nil {
        return &apierror.UnprocessableEntityError{
            Message: err.Error(),
            Order:   "H1",
        }
    }
    
    // Additional validation if needed
    // ...
}
```

**File Upload Validation:**
```go
// Validate file type and size
config := storage.FileValidationConfig{
    AllowedTypes: []string{"image/jpeg", "image/png", "image/gif"},
    MaxSize:      5 * 1024 * 1024, // 5MB
}

uploadResult, err := storage.UploadFileWithValidation(c, file, "/avatars/", config)
if err != nil {
    return err
}
```

## Testing Guidelines

### Test Structure

**Test Naming Convention:**
```go
// Pattern: Test{FunctionName}_{Scenario}_{ExpectedResult}
func TestRegister_ValidInput_Success(t *testing.T) {}
func TestRegister_DuplicateEmail_ReturnsError(t *testing.T) {}
func TestLogin_InvalidPassword_ReturnsUnauthorized(t *testing.T) {}
```

**Test Suite Pattern:**
```go
type UserTestSuite struct {
    suite.Suite
    app *fiber.App
    db  *gorm.DB
}

func (s *UserTestSuite) SetupTest() {
    s.db = SetupTestDB()
    s.app = SetupTestApp(s.db)
}

func (s *UserTestSuite) TearDownTest() {
    CleanupTestDB(s.db)
}

func (s *UserTestSuite) TestGetProfile_Success() {
    // Arrange
    user := createTestUser(s.db, "test@example.com")
    
    // Act
    resp := s.MakeRequest("GET", "/api/auth/profile", nil)
    
    // Assert
    s.AssertSuccessResponse(resp, 200)
}

func TestUserTestSuite(t *testing.T) {
    suite.Run(t, new(UserTestSuite))
}
```

**Coverage Requirements:**
- Minimum: 60% overall
- Critical paths: 80%+ (auth, payment, etc.)
- New features: Must include tests
- Bug fixes: Add regression tests

## Common Patterns to Follow

### Constructor Pattern

**ALWAYS** use constructor functions:
```go
func NewService(repo Repository) Service {
    return &serviceImpl{repo: repo}
}

func NewHandler(service Service) *Handler {
    return &Handler{service: service}
}

func NewRepository(db *gorm.DB) Repository {
    return &repositoryImpl{db: db}
}
```

### Response Pattern

**ALWAYS** use the response helper:
```go
return response.Response(dto.ResponseResult{
    StatusCode: fiber.StatusOK,
    Message:    "Success message",
    Data:       responseData,
}, c)
```

### Error Return Pattern

**ALWAYS** return custom errors with Order:
```go
if err != nil {
    return &apierror.InternalServerError{
        Message: "Clear error message",
        Order:   "S1",
    }
}
```

### File Upload Pattern

```go
// Get uploaded file
file, err := c.FormFile("avatar")
if err != nil {
    return &apierror.BadRequestError{
        Message: "File is required",
        Order:   "H1",
    }
}

// Validate and upload
config := storage.FileValidationConfig{
    AllowedTypes: []string{"image/jpeg", "image/png"},
    MaxSize:      5 * 1024 * 1024,
}

uploadResult, err := storage.UploadFileWithValidation(c, file, "/avatars/", config)
if err != nil {
    return err
}

// Use uploadResult.URL in your entity
```

## Anti-Patterns to Avoid

**CRITICAL - NEVER do these:**

1. ❌ **Mix layers in one file** - Don't put handler, service, and repository logic together
2. ❌ **Use snake_case** - Go uses camelCase/PascalCase, not snake_case
3. ❌ **Ignore errors** - Never use `_` to ignore errors
4. ❌ **Expose entities directly** - Always use DTOs for API responses
5. ❌ **Store plain passwords** - Always hash passwords before storing
6. ❌ **Skip authentication** - Never skip auth for sensitive endpoints
7. ❌ **Hardcode values** - Use environment variables and config
8. ❌ **Trust client IDs** - Always use authenticated user ID from JWT
9. ❌ **Return raw errors** - Always wrap errors with context
10. ❌ **Reverse dependencies** - Never make Service depend on Handler

## File Creation Workflow

When creating a new domain/feature (e.g., `product`):

### Step 1: Domain Layer (`internal/domain/product/`)

Create these files:
- `entity.go` - Define GORM model
- `dto.go` - Request/Response types with conversion methods
- `repository.go` - Repository interface
- `service.go` - Service interface

### Step 2: Repository (`internal/repository/postgres/product.go`)

- Implement repository interface
- Use GORM for database operations
- Return entities (not DTOs)

### Step 3: Service (`internal/service/product/service.go`)

- Implement business logic
- Use repository for data access
- Return DTOs (not entities)
- Handle errors with custom error types

### Step 4: Handler (`internal/handler/http/product.go`)

- Parse and validate requests
- Extract authenticated user from token
- Call service methods
- Return formatted responses

### Step 5: Routes (`router/product.go`)

- Create route file in `router/` folder
- Define route group
- Apply middleware (auth, rate limit, etc.)
- Register handlers
- Import handlers from `internal/handler/http/`

**Example: `router/product.go`**
```go
package router

import (
    "starter-gofiber/internal/config"
    "starter-gofiber/internal/handler/http"
    "starter-gofiber/internal/handler/middleware"
    "starter-gofiber/internal/repository/postgres"
    "starter-gofiber/internal/service/product"
    
    "github.com/gofiber/fiber/v2"
)

func NewProductRouter(app fiber.Router) {
    repo := postgres.NewProductRepository(config.DB)
    productService := product.NewProductService(repo)
    productHandler := http.NewProductHandler(productService)
    
    products := app.Group("/products")
    
    // Public routes
    products.Get("", productHandler.All)
    products.Get("/:id", productHandler.GetByID)
    
    // Protected routes
    authMiddleware := middleware.AuthMiddleware()
    products.Post("", authMiddleware, productHandler.Create)
    products.Put("/:id", authMiddleware, productHandler.Update)
    products.Delete("/:id", authMiddleware, productHandler.Delete)
}
```

**Then register in `router/router.go`:**
```go
func AppRouter(app *fiber.App) {
    api := app.Group("/api")
    NewProductRouter(api)
}
```

### Step 6: Database Migration

**IMPORTANT**: This project uses **Atlas** for database migrations, NOT golang-migrate!

**Add Model to Migration System:**
```go
// internal/config/database.go
func GetModelsForMigration() []interface{} {
    models := []interface{}{
        &user.User{},
        &post.Post{},
        &product.Product{}, // Add your new model here
        // ...
    }
    return models
}
```

**Generate & Apply Migration:**
```bash
# Generate migration from GORM schema
make atlas-diff

# Or with custom name
make atlas-diff-name NAME=create_products_table

# Review generated SQL
cat migrations/[timestamp]_create_products_table.sql

# Apply migration
make atlas-apply
```

**Key Points:**
- ✅ Register model ONCE in `GetModelsForMigration()` 
- ✅ Both AutoMigrate (dev) and Atlas (prod) use same models
- ✅ No manual SQL writing needed - Atlas generates from GORM
- ✅ Single source of truth for all models

### Step 7: Tests (`tests/product_test.go`)

- Create test suite
- Add integration tests
- Test critical paths

## Code Examples

### Complete CRUD Example: User Profile

**Handler:**
```go
func (h *AuthHandler) GetProfile(c *fiber.Ctx) error {
    userClaims, err := crypto.GetUserFromToken(c)
    if err != nil {
        return err
    }
    
    profile, err := h.userS.GetProfile(userClaims.ID)
    if err != nil {
        return err
    }
    
    return response.Response(dto.ResponseResult{
        StatusCode: fiber.StatusOK,
        Message:    "Profile retrieved successfully",
        Data:       profile,
    }, c)
}

func (h *AuthHandler) UpdateProfile(c *fiber.Ctx) error {
    userClaims, err := crypto.GetUserFromToken(c)
    if err != nil {
        return err
    }
    
    var req user.UpdateProfileRequest
    if err := c.BodyParser(&req); err != nil {
        return &apierror.UnprocessableEntityError{
            Message: err.Error(),
            Order:   "H1",
        }
    }
    
    profile, err := h.userS.UpdateProfile(userClaims.ID, &req)
    if err != nil {
        return err
    }
    
    return response.Response(dto.ResponseResult{
        StatusCode: fiber.StatusOK,
        Message:    "Profile updated successfully",
        Data:       profile,
    }, c)
}
```

**Service:**
```go
func (s *AuthService) GetProfile(userID uint) (*user.GetProfileResponse, error) {
    usr, err := s.userRepo.FindByID(userID)
    if err != nil {
        return nil, &apierror.NotFoundError{
            Message: "User not found",
            Order:   "S1",
        }
    }
    
    response := user.GetProfileResponse{}.FromEntity(*usr)
    return &response, nil
}

func (s *AuthService) UpdateProfile(userID uint, req *user.UpdateProfileRequest) (*user.GetProfileResponse, error) {
    usr, err := s.userRepo.FindByID(userID)
    if err != nil {
        return nil, &apierror.NotFoundError{
            Message: "User not found",
            Order:   "S1",
        }
    }
    
    if req.Name != "" {
        usr.Name = req.Name
    }
    if req.Bio != "" {
        usr.Bio = req.Bio
    }
    
    if err := s.userRepo.Update(usr); err != nil {
        return nil, &apierror.InternalServerError{
            Message: err.Error(),
            Order:   "S2",
        }
    }
    
    response := user.GetProfileResponse{}.FromEntity(*usr)
    return &response, nil
}
```

### Pagination Example

```go
// Service
func (s *PostService) GetAll(page, pageSize int) (*post.PostListResponse, error) {
    posts, total, err := s.postRepo.FindAll(page, pageSize)
    if err != nil {
        return nil, &apierror.InternalServerError{
            Message: err.Error(),
            Order:   "S1",
        }
    }
    
    totalPages := int(math.Ceil(float64(total) / float64(pageSize)))
    
    var responses []post.PostResponse
    for _, p := range posts {
        responses = append(responses, post.PostResponse{}.FromEntity(p))
    }
    
    return &post.PostListResponse{
        Posts: responses,
        Meta: post.PaginationMeta{
            Page:       page,
            PageSize:   pageSize,
            Total:      int(total),
            TotalPages: totalPages,
        },
    }, nil
}

// Handler
func (h *PostHandler) GetAll(c *fiber.Ctx) error {
    page, _ := strconv.Atoi(c.Query("page", "1"))
    pageSize, _ := strconv.Atoi(c.Query("per_page", "10"))
    
    resp, err := h.service.GetAll(page, pageSize)
    if err != nil {
        return err
    }
    
    return response.Response(dto.ResponseResult{
        StatusCode: fiber.StatusOK,
        Message:    "Posts retrieved successfully",
        Data:       resp.Posts,
        Paginate:   &dto.Pagination{
            Page:       resp.Meta.Page,
            PerPage:    resp.Meta.PageSize,
            Total:      resp.Meta.Total,
            TotalPages: resp.Meta.TotalPages,
        },
    }, c)
}
```

## Summary Checklist

When generating code, ALWAYS ensure:

- [ ] Follows Clean Architecture layers (Domain → Repository → Service → Handler)
- [ ] Uses proper naming conventions (camelCase/PascalCase, no snake_case)
- [ ] Imports organized (stdlib → external → internal)
- [ ] Uses custom error types with Order field
- [ ] Returns DTOs from service, not entities
- [ ] Extracts user from JWT token, never trusts client ID
- [ ] Uses response.Response() helper for all responses
- [ ] Validates input at handler level
- [ ] Includes proper error handling with context
- [ ] Follows constructor pattern for all structs
- [ ] Creates migration files for schema changes
- [ ] Includes tests for new features
- [ ] Comment the documentation above each function created with english language
- [ ] Creates Postman collection for new features api documentation
---

**Remember**: This codebase follows Clean Architecture principles. Always maintain layer separation and dependency direction. 

**Router Structure:**
- All route definitions go in `router/` folder (e.g., `router/auth.go`, `router/post.go`)
- Handlers remain in `internal/handler/http/` folder
- Router imports handlers, not the other way around

When in doubt, refer to existing implementations:
- Domain: `internal/domain/user/`
- Service: `internal/service/auth/service.go`
- Handler: `internal/handler/http/auth.go`
- Router: `router/auth.go`

---

## Database Migration System (Atlas)

### Why Atlas?

This project uses **Atlas with GORM Provider** instead of golang-migrate for automatic schema migrations.

**Benefits:**
- ✅ Auto-generate migrations from GORM models
- ✅ No manual SQL writing needed
- ✅ Type-safe migrations from Go code
- ✅ Single source of truth for models
- ✅ Version control friendly
- ✅ CI/CD ready

### Single Source of Truth

**All models are defined in ONE place:**

```go
// internal/config/database.go
func GetModelsForMigration() []interface{} {
    models := []interface{}{
        &user.User{},
        &post.Post{},
        &user.RefreshToken{},
        &user.PasswordReset{},
        &user.EmailVerification{},
        &user.APIKey{},
        &user.UserPreferences{},
    }

    // Add AuditLog if enabled
    if ENV.AUDIT_LOG_ENABLE {
        models = append(models, &database.AuditLog{})
    }

    return models
}
```

**This function is used by:**
1. **AutoMigrate** (Development: `DB_GEN=true`) - Auto-sync schema on startup
2. **Atlas Loader** (Production: `DB_GEN=false`) - Generate migration files

### Migration Workflow

#### Development Mode (Fast Iteration)

```bash
# Set in .env
DB_GEN=true

# Run app - schema auto-syncs
go run ./cmd/api
```

Schema changes applied automatically via `db.AutoMigrate()`.

#### Production Mode (Controlled Migrations)

```bash
# Set in .env
DB_GEN=false
```

**1. Add New Model:**
```go
// internal/domain/category/entity.go
type Category struct {
    ID   uint   `gorm:"primaryKey"`
    Name string `gorm:"type:varchar(100);not null"`
    gorm.Model
}
```

**2. Register in Config:**
```go
// internal/config/database.go
func GetModelsForMigration() []interface{} {
    return []interface{}{
        &user.User{},
        &category.Category{}, // Add here
    }
}
```

**3. Generate Migration:**
```bash
make atlas-diff
# or with custom name
make atlas-diff-name NAME=add_categories_table
```

**4. Review Generated SQL:**
```bash
cat migrations/20260107120000_add_categories_table.sql
```

**5. Apply Migration:**
```bash
make atlas-apply  # development
make atlas-apply-prod  # production (with confirmation)
```

### Makefile Commands

All Atlas commands are integrated in main `Makefile`:

```bash
make atlas-install       # Install Atlas CLI
make atlas-diff          # Generate migration
make atlas-diff-name     # Generate with custom name
make atlas-apply         # Apply migrations
make atlas-status        # Check status
make atlas-validate      # Validate migrations
make atlas-inspect       # Inspect schema
make atlas-migrate       # Full workflow (diff+validate+apply)
make atlas-test          # Dry run

# Legacy (deprecated, shows warnings)
make migrate-up          # Alias for atlas-apply
make migrate-status      # Alias for atlas-status
```

View all commands:
```bash
make help
```

### Atlas Configuration

**Project Files:**
- `atlas.hcl` - Atlas configuration
- `cmd/atlas/main.go` - GORM schema loader
- `internal/config/database.go` - Models definition (single source of truth)
- `migrations/` - Generated migration files
- `Makefile` - Atlas commands

**Key Principle**: NEVER duplicate model lists. Always use `GetModelsForMigration()`.

---

## CMD Folder Convention

### CRITICAL Rule: Each subfolder MUST have `main.go`

**Structure:**
```
cmd/
├── api/
│   └── main.go       ✅ REQUIRED
├── worker/
│   └── main.go       ✅ REQUIRED
└── atlas/
    └── main.go       ✅ REQUIRED
```

### Why `main.go`?

1. **Go Standard** - Official Go convention for executable programs
2. **Easy to Run** - `go run ./cmd/<program>`
3. **Easy to Build** - `go build -o bin/<name> ./cmd/<program>`
4. **Clear Intent** - Immediately obvious it's an executable

### ❌ WRONG

```
cmd/
├── api/
│   └── server.go     ❌ Should be main.go
│   └── app.go        ❌ Should be main.go
```

### ✅ CORRECT

```
cmd/
├── api/
│   └── main.go       ✅ Entry point
│   └── config.go     ✅ Helper files OK
```

### Running Programs

```bash
# Development
go run ./cmd/api
go run ./cmd/worker
go run ./cmd/atlas

# Production
go build -o bin/api ./cmd/api
go build -o bin/worker ./cmd/worker
./bin/api
```

### Creating New Program

```bash
mkdir -p cmd/myprogram
```

```go
// cmd/myprogram/main.go
package main

import "starter-gofiber/internal/config"

func main() {
    config.LoadConfig()
    // Your logic here
}
```

**Rules:**
- ✅ MUST have `package main`
- ✅ MUST have `func main()`
- ✅ MUST be in file named `main.go`
- ❌ ONE `main.go` per package only
- ❌ NO business logic in main.go (keep it simple)

---

## Makefile Commands

All automation tasks are in main `Makefile`:

### Database & Migration

```bash
make atlas-install      # Install Atlas CLI
make atlas-diff         # Generate migration
make atlas-apply        # Apply migrations
make atlas-status       # Check status
make atlas-migrate      # Full workflow
```

### Build & Run

```bash
make build              # Build all
make build-api          # Build API only
make run                # Run API
make run-air            # Run with live reload
make run-worker         # Run worker
```

### Testing

```bash
make test               # Run all tests
make test-coverage      # With coverage report
make test-short         # Quick tests
```

### Code Quality

```bash
make fmt                # Format code
make lint               # Run linter
make vet                # Run go vet
make mod-tidy           # Tidy dependencies
```

### Docker

```bash
make docker-build       # Build image
make docker-up          # Start services
make docker-down        # Stop services
make docker-logs        # View logs
```

### Development

```bash
make dev-setup          # Full setup (tools + deps + Atlas)
make install-tools      # Install dev tools
make clean              # Clean artifacts
```

**View All Commands:**
```bash
make help
```

**Documentation:**
- See [docs/MAKEFILE_COMMANDS.md](docs/MAKEFILE_COMMANDS.md) for complete reference
- See [docs/MIGRATION_GUIDE.md](docs/MIGRATION_GUIDE.md) for Atlas migration guide

---

## Documentation Organization

All documentation is organized in `docs/` folder:

### Architecture & Setup
- `docs/ARCHITECTURE.md` - Clean Architecture pattern
- `docs/MIGRATION_GUIDE.md` - Atlas migration quick start (Bahasa Indonesia)
- `docs/DATABASE.md` - Database management complete guide
- `docs/MAKEFILE_COMMANDS.md` - Makefile commands reference
- `cmd/README.md` - CMD folder conventions

### Security & Auth
- `docs/API_AUTH.md` - Authentication endpoints
- `docs/SECURITY.md` - Security features overview
- `docs/SECURITY_IMPLEMENTATION.md` - Security implementation details

### API & Performance
- `docs/API_FEATURES.md` - Advanced API features
- `docs/PERFORMANCE.md` - Performance optimization
- `docs/CACHING.md` - Redis caching system

### Data & Storage
- `docs/FILE_MANAGEMENT.md` - File upload & cloud storage
- `docs/CLOUD_STORAGE_EXAMPLES.md` - Cloud storage examples
- `docs/MINIO_SETUP.md` - MinIO local S3 setup

### Background Jobs & Real-time
- `docs/BACKGROUND_JOBS.md` - Asynq background jobs
- `docs/SSE.md` - Server-Sent Events
- `docs/EMAIL.md` - Email system

### Monitoring & Testing
- `docs/LOGGING_MONITORING.md` - Logging with Zap & Sentry
- `docs/METRICS_MONITORING.md` - Metrics & health checks
- `docs/TESTING.md` - Testing guidelines
- `docs/TEST_COVERAGE.md` - Coverage reports

### Deployment
- `docs/DEPLOYMENT.md` - Deployment guide
- `docs/DEVOPS.md` - CI/CD & DevOps setup

**Always reference docs in comments and error messages when relevant.**

---

## Quick Reference

### Adding New Feature (Complete Flow)

1. **Create Domain** - `internal/domain/product/`
   - `entity.go` - GORM model
   - `dto.go` - Request/Response DTOs
   - `repository.go` - Repository interface
   - `service.go` - Service interface

2. **Implement Repository** - `internal/repository/postgres/product.go`
   - Implement repository interface
   - Use GORM for DB operations

3. **Implement Service** - `internal/service/product/service.go`
   - Implement business logic
   - Return DTOs, not entities

4. **Implement Handler** - `internal/handler/http/product.go`
   - Parse requests
   - Call service
   - Return responses

5. **Register Routes** - `router/product.go`
   - Define endpoints
   - Apply middleware
   - Register handlers

6. **Add to Migration** - `internal/config/database.go`
   ```go
   func GetModelsForMigration() []interface{} {
       return []interface{}{
           &product.Product{}, // Add here
       }
   }
   ```

7. **Generate Migration**:
   ```bash
   make atlas-diff-name NAME=create_products_table
   make atlas-apply
   ```

8. **Add Tests** - `tests/product_test.go`
   - Integration tests
   - Test critical paths

### Common Commands

```bash
# Development
make run-air            # Start with live reload
make atlas-diff         # Generate migration
make atlas-apply        # Apply migration
make test               # Run tests

# Production
make build              # Build binaries
make atlas-apply-prod   # Apply migrations (with confirm)
./bin/api               # Run production binary
```

### File Naming Conventions

- **Files**: lowercase_underscore.go (`user_repository.go`)
- **Packages**: lowercase, single word (`postgres`, `auth`)
- **Variables**: camelCase (`userRepo`, `authService`)
- **Functions**: camelCase (private) or PascalCase (exported)
- **Structs**: PascalCase (`User`, `UserRepository`)
- **Constants**: PascalCase (`DefaultPageSize`)

### Import Order

```go
import (
    // 1. Standard library
    "fmt"
    "time"
    
    // 2. External packages
    "github.com/gofiber/fiber/v2"
    "gorm.io/gorm"
    
    // 3. Internal packages
    "starter-gofiber/internal/domain/user"
    "starter-gofiber/pkg/apierror"
)
```

---

**Remember**: Follow Clean Architecture, maintain single source of truth, and always reference documentation when needed!
